diff -Naurb udftools-1.0.0b3/cdmrw/cdmrw.c udftools-1.0.0b3+cdmrw/cdmrw/cdmrw.c
--- udftools-1.0.0b3/cdmrw/cdmrw.c	1970-01-01 01:00:00.000000000 +0100
+++ udftools-1.0.0b3+cdmrw/cdmrw/cdmrw.c	2004-03-25 13:21:58.763957610 +0100
@@ -0,0 +1,581 @@
+/*
+ * Copyright (c) 2002 Jens Axboe <axboe@suse.de>
+ *
+ * cdmrw -- utility to manage mt rainier cd drives + media
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License version 2 as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <byteswap.h>
+#include <sys/ioctl.h>
+
+/* originally was
+ * #include <linux/cdrom.h>
+ */
+#include "cdrom.h"
+
+#define INIT_CGC(cgc)	memset((cgc), 0, sizeof(struct cdrom_generic_command))
+
+#define FORMAT_TYPE_RESTART	1
+#define FORMAT_TYPE_FULL	2
+
+#define LBA_DMA			0
+#define LBA_GAA			1
+
+/*
+ * early mrw drives may use mode page 0x2c still, 0x03 is the official one
+ */
+#define MRW_MODE_PC_PRE1	0x2c
+#define MRW_MODE_PC		0x03
+
+#define UHZ			100
+
+static int format_type, format_force, poll_wait, poll_err, suspend_format;
+static int lba_space = -1, mrw_mode_page;
+
+static char mrw_device[256];
+
+static char *lba_spaces[] = { "DMA", "GAA" };
+
+void dump_cgc(struct cdrom_generic_command *cgc)
+{
+	struct request_sense *sense = cgc->sense;
+	int i;
+
+	printf("cdb: ");
+	for (i = 0; i < 12; i++)
+		printf("%02x ", cgc->cmd[i]);
+	printf("\n");
+
+	printf("buffer (%d): ", cgc->buflen);
+	for (i = 0; i < cgc->buflen; i++)
+		printf("%02x ", cgc->buffer[i]);
+	printf("\n");
+
+	if (!sense)
+		return;
+
+	printf("sense: %02x.%02x.%02x\n", sense->sense_key, sense->asc, sense->ascq);
+}
+
+/*
+ * issue packet command (blocks until it has completed)
+ */
+int wait_cmd(int fd, struct cdrom_generic_command *cgc, void *buffer,
+	     int len, int ddir, int timeout, int quiet)
+{
+	struct request_sense sense;
+	int ret;
+
+	memset(&sense, 0, sizeof(sense));
+
+	cgc->timeout = timeout;
+	cgc->buffer = buffer;
+	cgc->buflen = len;
+	cgc->data_direction = ddir;
+	cgc->sense = &sense;
+	cgc->quiet = 0;
+
+	ret = ioctl(fd, CDROM_SEND_PACKET, cgc);
+	if (ret == -1 && !quiet) {
+		perror("ioctl");
+		dump_cgc(cgc);
+	}
+
+	return ret;
+}
+
+int start_bg_format(int fd, int new)
+{
+	struct cdrom_generic_command cgc;
+	unsigned char buffer[12];
+
+	INIT_CGC(&cgc);
+	memset(buffer, 0, sizeof(buffer));
+
+	cgc.cmd[0] = GPCMD_FORMAT_UNIT;
+	cgc.cmd[1] = (1 << 4) | 1;
+
+	buffer[1] = 1 << 1;
+	buffer[3] = 8;
+
+	buffer[4] = 0xff;
+	buffer[5] = 0xff;
+	buffer[6] = 0xff;
+	buffer[7] = 0xff;
+	buffer[8] = 0x24 << 2;
+	buffer[11] = !new;
+
+	return wait_cmd(fd, &cgc, buffer, sizeof(buffer), CGC_DATA_WRITE, 120 * UHZ, 0);
+}
+
+/*
+ * instantiate a format, if appropriate
+ */
+int mrw_format(int fd, int media_status)
+{
+	if (media_status == CDM_MRW_BGFORMAT_ACTIVE) {
+		printf("%s: back ground format already active\n", mrw_device);
+		return 1;
+	} else if (media_status == CDM_MRW_BGFORMAT_COMPLETE && !format_force) {
+		printf("%s: disc is already mrw formatted\n", mrw_device);
+		return 1;
+	}
+
+	if (format_type == FORMAT_TYPE_RESTART && media_status != CDM_MRW_BGFORMAT_INACTIVE) {
+		printf("%s: can't restart format, need full\n", mrw_device);
+		return 1;
+	}
+
+	return start_bg_format(fd, format_type == FORMAT_TYPE_FULL);
+}
+
+int mrw_format_suspend(int fd, int media_status)
+{
+	struct cdrom_generic_command cgc;
+
+	if (media_status != CDM_MRW_BGFORMAT_ACTIVE) {
+		printf("%s: can't suspend, format not running\n", mrw_device);
+		return 1;
+	}
+
+	printf("%s: suspending back ground format: ", mrw_device);
+
+	INIT_CGC(&cgc);
+
+	cgc.cmd[0] = GPCMD_CLOSE_TRACK;
+	cgc.cmd[1] = 0; /* IMMED */
+	cgc.cmd[2] = 1 << 1;
+
+	if (wait_cmd(fd, &cgc, NULL, 0, CGC_DATA_NONE, 300 * UHZ, 0)) {
+		printf("failed\n");
+		return 1;
+	}
+
+	printf("done\n");
+	return 0;
+}
+
+int get_media_event(int fd)
+{
+	struct cdrom_generic_command cgc;
+	unsigned char buffer[8];
+	int ret;
+
+	INIT_CGC(&cgc);
+	memset(buffer, 0, sizeof(buffer));
+
+	cgc.cmd[0] = GPCMD_GET_EVENT_STATUS_NOTIFICATION;
+	cgc.cmd[1] = 1;
+	cgc.cmd[4] = 16;
+	cgc.cmd[8] = sizeof(buffer);
+
+	ret = wait_cmd(fd, &cgc, buffer, sizeof(buffer), CGC_DATA_READ, 10*UHZ, 0);
+	if (ret < 0) {
+		perror("GET_EVENT");
+		return ret;
+	}
+
+	return buffer[4] & 0xf;
+}
+
+int get_progress(int fd)
+{
+	struct cdrom_generic_command cgc;
+	struct request_sense sense;
+	int progress;
+
+	INIT_CGC(&cgc);
+	memset(&sense, 0, sizeof(sense));
+
+	cgc.cmd[0] = GPCMD_TEST_UNIT_READY;
+	cgc.sense = &sense;
+
+	(void) wait_cmd(fd, &cgc, NULL, 0, CGC_DATA_NONE, 10 * UHZ, 0);
+
+	printf("progress: ");
+	if (sense.sks[0] & 0x80) {
+		progress = (sense.sks[1] << 8) + sense.sks[2];
+		fprintf(stderr, "%d%%\r", progress);
+	} else
+		printf("no progress indicator\n");
+
+	return 0;
+}
+
+int get_format_progress(int fd)
+{
+	struct cdrom_generic_command cgc;
+	struct request_sense sense;
+
+#if 0
+	if (poll_err)
+		return 0;
+#endif
+
+	INIT_CGC(&cgc);
+	memset(&sense, 0, sizeof(sense));
+
+	cgc.cmd[0] = GPCMD_TEST_UNIT_READY;
+	cgc.sense = &sense;
+
+	if (wait_cmd(fd, &cgc, NULL, 0, CGC_DATA_NONE, 10 * UHZ, 0)) {
+		printf("%s: TUR failed\n", mrw_device);
+		return 0;
+	}
+
+	/*
+	 * all mrw drives should support progress indicator, but you never
+	 * know...
+	 */
+	if (!(sense.sks[0] & 0x80)) {
+		printf("drive fails to support progress indicator\n");
+		poll_err = 1;
+		//return 0;
+	}
+
+	return (sense.sks[1] << 8) + sense.sks[2];
+}
+
+/*
+ * return mrw media status bits from disc info or -1 on failure
+ */
+int get_mrw_media_status(int fd)
+{
+	struct cdrom_generic_command cgc;
+	disc_information di;
+
+	INIT_CGC(&cgc);
+
+	cgc.cmd[0] = GPCMD_READ_DISC_INFO;
+	cgc.cmd[8] = sizeof(di);
+
+	if (wait_cmd(fd, &cgc, &di, sizeof(di), CGC_DATA_READ, UHZ, 0)) {
+		printf("read disc info failed\n");
+		return -1;
+	}
+
+	return di.mrw_status;
+}
+
+int poll_events(int fd)
+{
+	int event, quit, first, progress, media_status;
+
+	quit = 0;
+	first = 1;
+	do {
+		event = get_media_event(fd);
+		if (event < 0)
+			break;
+
+		switch (event) {
+			case 0:
+				if (first)
+					printf("no media change\n");
+				break;
+			case 1:
+				printf("eject request\n");
+				if ((media_status = get_mrw_media_status(fd)) == -1)
+					break;
+				if (media_status == CDM_MRW_BGFORMAT_ACTIVE)
+					mrw_format_suspend(fd, media_status);
+				quit = 1;
+				break;
+			case 2:
+				printf("new media\n");
+				break;
+			case 3:
+				printf("media removal\n");
+				quit = 1;
+				break;
+			case 4:
+				printf("media change\n");
+				break;
+			case 5:
+				printf("bgformat complete!\n");
+				quit = 1;
+				break;
+			case 6:
+				printf("bgformat automatically restarted\n");
+				break;
+			default:
+				printf("unknown media event (%d)\n", event);
+				break;
+		}
+
+		if (!quit) {
+			first = 0;
+			progress = get_progress(fd);
+			if (event)
+				continue;
+
+			sleep(2);
+		}
+
+	} while (!quit);
+
+	return event;
+}
+
+/*
+ * issue GET_CONFIGURATION and check for the mt rainier profile
+ */
+int check_for_mrw(int fd)
+{
+	struct mrw_feature_desc *mfd;
+	struct cdrom_generic_command cgc;
+	char buffer[16];
+
+	INIT_CGC(&cgc);
+
+	cgc.cmd[0] = GPCMD_GET_CONFIGURATION;
+	cgc.cmd[3] = CDF_MRW;
+	cgc.cmd[8] = sizeof(buffer);
+
+	if (wait_cmd(fd, &cgc, buffer, sizeof(buffer), CGC_DATA_READ, UHZ, 1))
+		return 1;
+
+	mfd = (struct mrw_feature_desc *)&buffer[sizeof(struct feature_header)];
+
+	return !mfd->write;
+}
+
+int __get_lba_space(int fd, int pc, char *buffer, int size)
+{
+	struct cdrom_generic_command cgc;
+
+	INIT_CGC(&cgc);
+
+	cgc.cmd[0] = GPCMD_MODE_SENSE_10;
+	cgc.cmd[2] = pc | (0 << 6);
+	cgc.cmd[8] = size;
+
+	if (wait_cmd(fd, &cgc, buffer, size, CGC_DATA_READ, UHZ, 1))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * return LBA_DMA or LBA_GAA, -1 on failure
+ */
+int get_lba_space(int fd)
+{
+	struct mode_page_header *mph;
+	char buffer[32];
+	int offset;
+
+	if (__get_lba_space(fd, mrw_mode_page, buffer, sizeof(buffer)))
+		return -1;
+
+	mph = (struct mode_page_header *) buffer;
+	offset = sizeof(*mph) + bswap_16(mph->desc_length);
+
+	/*
+	 * LBA space bit is bit 0 in byte 3 of the mrw mode page
+	 */
+	return buffer[offset + 3] & 1;
+}
+
+int probe_mrw_mode_page(int fd)
+{
+	char buffer[32];
+
+	mrw_mode_page = -1;
+
+	if (!__get_lba_space(fd, MRW_MODE_PC, buffer, sizeof(buffer)))
+		mrw_mode_page = MRW_MODE_PC;
+	else if (!__get_lba_space(fd, MRW_MODE_PC_PRE1, buffer, sizeof(buffer)))
+		mrw_mode_page = MRW_MODE_PC_PRE1;
+
+	if (mrw_mode_page == MRW_MODE_PC_PRE1)
+		printf("%s: still using deprecated mrw mode page\n",mrw_device);
+
+	return mrw_mode_page;
+}
+
+int switch_lba_space(int fd, int lba_space)
+{
+	struct cdrom_generic_command cgc;
+	struct mode_page_header *mph;
+	int cur_space, offset, size;
+	char buffer[32];
+
+	if (__get_lba_space(fd, mrw_mode_page, buffer, sizeof(buffer)))
+		return 1;
+
+	mph = (struct mode_page_header *) buffer;
+	offset = sizeof(*mph) + bswap_16(mph->desc_length);
+	cur_space = buffer[offset + 3] & 1;
+
+	if (cur_space == lba_space)
+		return 0;
+
+	/*
+	 * mode data length doesn't include its own space
+	 */
+	size = bswap_16(mph->mode_data_length) + 2;
+
+	/*
+	 * init command and set the required lba space
+	 */
+	INIT_CGC(&cgc);
+
+	cgc.cmd[0] = GPCMD_MODE_SELECT_10;
+	cgc.cmd[8] = size;
+
+	buffer[offset + 3] = lba_space;
+
+	if (wait_cmd(fd, &cgc, buffer, size, CGC_DATA_WRITE, UHZ, 0))
+		return 1;
+
+	return 0;
+}
+
+void print_mrw_status(int media_status)
+{
+	switch (media_status) {
+		case CDM_MRW_NOTMRW:
+			printf("not a mrw formatted disc\n");
+			break;
+		case CDM_MRW_BGFORMAT_INACTIVE:
+			printf("mrw format inactive and not complete\n");
+			break;
+		case CDM_MRW_BGFORMAT_ACTIVE:
+			printf("mrw format running\n");
+			break;
+		case CDM_MRW_BGFORMAT_COMPLETE:
+			printf("disc is mrw formatted\n");
+			break;
+	}
+}
+
+void print_options(const char *prg)
+{
+	printf("%s: options:\n", prg);
+	printf("\t-d:\t<device>\n");
+	printf("\t-f:\t<{restart, full} format type\n");
+	printf("\t-F:\tforce format\n");
+	printf("\t-s:\tsuspend format\n");
+	printf("\t-p:\tpoll for format completion\n");
+}
+
+void get_options(int argc, char *argv[])
+{
+	char c;
+
+	strcpy(mrw_device, "/dev/cdrom");
+
+	while ((c = getopt(argc, argv, "d:f:Fpsl:")) != EOF) {
+		switch (c) {
+			case 'd':
+				strcpy(mrw_device, optarg);
+				break;
+			case 'f':
+				if (!strcmp(optarg, "full"))
+					format_type = FORMAT_TYPE_FULL;
+				else if (!strcmp(optarg, "restart"))
+					format_type = FORMAT_TYPE_RESTART;
+				else
+					printf("%s: invalid format type %s\n", argv[0], optarg);
+				break;
+			case 'F':
+				format_force = 1;
+				break;
+			case 'p':
+				poll_wait = 1;
+				break;
+			case 's':
+				suspend_format = 1;
+				break;
+			case 'l':
+				if (!strcmp(optarg, "gaa"))
+					lba_space = LBA_GAA;
+				else if (!strcmp(optarg, "dma"))
+					lba_space = LBA_DMA;
+				else
+					printf("%s: invalid address space %s\n", argv[0], optarg);
+				break;
+			default:
+				if (optarg)
+					printf("%s: unknown option '%s'\n", argv[0], optarg);
+				print_options(argv[0]);
+				exit(1);
+		}
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	int fd, media_status, progress;
+
+	if (argc == 1) {
+		print_options(argv[0]);
+		return 1;
+	}
+
+	get_options(argc, argv);
+
+	fd = open(mrw_device, O_RDONLY | O_NONBLOCK);
+	if (fd == -1) {
+		perror("open");
+		return 1;
+	}
+
+	if (check_for_mrw(fd)) {
+		printf("%s: %s is not a mrw drive or mrw reader\n", argv[0], mrw_device);
+		return 1;
+	}
+
+	if ((media_status = get_mrw_media_status(fd)) == -1) {
+		printf("%s: failed to retrieve media status\n", argv[0]);
+		return 1;
+	}
+
+	print_mrw_status(media_status);
+
+	if (probe_mrw_mode_page(fd) == -1) {
+		printf("%s: failed to probe mrw mode page\n", mrw_device);
+		return 1;
+	}
+
+	if (lba_space != -1) {
+		if (switch_lba_space(fd, lba_space)) {
+			printf("%s: failed switching lba space\n", mrw_device);
+			return 1;
+		}
+	}
+
+	printf("LBA space: %s\n", lba_spaces[get_lba_space(fd)]);
+
+	if (media_status == CDM_MRW_BGFORMAT_ACTIVE) {
+		progress = get_format_progress(fd);
+		printf("%s: back ground format %d%% complete\n", mrw_device, progress);
+	}
+
+	if (format_type) {
+		if (mrw_format(fd, media_status))
+			return 1;
+	} else if (suspend_format)
+		mrw_format_suspend(fd, media_status);
+
+	if (poll_wait)
+		poll_events(fd);
+
+	return 0;
+}
diff -Naurb udftools-1.0.0b3/cdmrw/cdrom.h udftools-1.0.0b3+cdmrw/cdmrw/cdrom.h
--- udftools-1.0.0b3/cdmrw/cdrom.h	1970-01-01 01:00:00.000000000 +0100
+++ udftools-1.0.0b3+cdmrw/cdmrw/cdrom.h	2004-03-25 04:33:08.000000000 +0100
@@ -0,0 +1,1181 @@
+/*
+ * -- <linux/cdrom.h>
+ * General header file for linux CD-ROM drivers 
+ * Copyright (C) 1992         David Giller, rafetmad@oxy.edu
+ *               1994, 1995   Eberhard Moenkeberg, emoenke@gwdg.de
+ *               1996         David van Leeuwen, david@tm.tno.nl
+ *               1997, 1998   Erik Andersen, andersee@debian.org
+ *               1998-2002    Jens Axboe, axboe@suse.de
+ */
+ 
+#ifndef	_LINUX_CDROM_H
+#define	_LINUX_CDROM_H
+
+#include <asm/byteorder.h>
+
+/*******************************************************
+ * As of Linux 2.1.x, all Linux CD-ROM application programs will use this 
+ * (and only this) include file.  It is my hope to provide Linux with
+ * a uniform interface between software accessing CD-ROMs and the various 
+ * device drivers that actually talk to the drives.  There may still be
+ * 23 different kinds of strange CD-ROM drives, but at least there will 
+ * now be one, and only one, Linux CD-ROM interface.
+ *
+ * Additionally, as of Linux 2.1.x, all Linux application programs 
+ * should use the O_NONBLOCK option when opening a CD-ROM device 
+ * for subsequent ioctl commands.  This allows for neat system errors 
+ * like "No medium found" or "Wrong medium type" upon attempting to 
+ * mount or play an empty slot, mount an audio disc, or play a data disc.
+ * Generally, changing an application program to support O_NONBLOCK
+ * is as easy as the following:
+ *       -    drive = open("/dev/cdrom", O_RDONLY);
+ *       +    drive = open("/dev/cdrom", O_RDONLY | O_NONBLOCK);
+ * It is worth the small change.
+ *
+ *  Patches for many common CD programs (provided by David A. van Leeuwen)
+ *  can be found at:  ftp://ftp.gwdg.de/pub/linux/cdrom/drivers/cm206/
+ * 
+ *******************************************************/
+
+/* When a driver supports a certain function, but the cdrom drive we are 
+ * using doesn't, we will return the error EDRIVE_CANT_DO_THIS.  We will 
+ * borrow the "Operation not supported" error from the network folks to 
+ * accomplish this.  Maybe someday we will get a more targeted error code, 
+ * but this will do for now... */
+#define EDRIVE_CANT_DO_THIS  EOPNOTSUPP
+
+/*******************************************************
+ * The CD-ROM IOCTL commands  -- these should be supported by 
+ * all the various cdrom drivers.  For the CD-ROM ioctls, we 
+ * will commandeer byte 0x53, or 'S'.
+ *******************************************************/
+#define CDROMPAUSE		0x5301 /* Pause Audio Operation */ 
+#define CDROMRESUME		0x5302 /* Resume paused Audio Operation */
+#define CDROMPLAYMSF		0x5303 /* Play Audio MSF (struct cdrom_msf) */
+#define CDROMPLAYTRKIND		0x5304 /* Play Audio Track/index 
+                                           (struct cdrom_ti) */
+#define CDROMREADTOCHDR		0x5305 /* Read TOC header 
+                                           (struct cdrom_tochdr) */
+#define CDROMREADTOCENTRY	0x5306 /* Read TOC entry 
+                                           (struct cdrom_tocentry) */
+#define CDROMSTOP		0x5307 /* Stop the cdrom drive */
+#define CDROMSTART		0x5308 /* Start the cdrom drive */
+#define CDROMEJECT		0x5309 /* Ejects the cdrom media */
+#define CDROMVOLCTRL		0x530a /* Control output volume 
+                                           (struct cdrom_volctrl) */
+#define CDROMSUBCHNL		0x530b /* Read subchannel data 
+                                           (struct cdrom_subchnl) */
+#define CDROMREADMODE2		0x530c /* Read CDROM mode 2 data (2336 Bytes) 
+                                           (struct cdrom_read) */
+#define CDROMREADMODE1		0x530d /* Read CDROM mode 1 data (2048 Bytes)
+                                           (struct cdrom_read) */
+#define CDROMREADAUDIO		0x530e /* (struct cdrom_read_audio) */
+#define CDROMEJECT_SW		0x530f /* enable(1)/disable(0) auto-ejecting */
+#define CDROMMULTISESSION	0x5310 /* Obtain the start-of-last-session 
+                                           address of multi session disks 
+                                           (struct cdrom_multisession) */
+#define CDROM_GET_MCN		0x5311 /* Obtain the "Universal Product Code" 
+                                           if available (struct cdrom_mcn) */
+#define CDROM_GET_UPC		CDROM_GET_MCN  /* This one is depricated, 
+                                          but here anyway for compatibility */
+#define CDROMRESET		0x5312 /* hard-reset the drive */
+#define CDROMVOLREAD		0x5313 /* Get the drive's volume setting 
+                                          (struct cdrom_volctrl) */
+#define CDROMREADRAW		0x5314	/* read data in raw mode (2352 Bytes)
+                                           (struct cdrom_read) */
+/* 
+ * These ioctls are used only used in aztcd.c and optcd.c
+ */
+#define CDROMREADCOOKED		0x5315	/* read data in cooked mode */
+#define CDROMSEEK		0x5316  /* seek msf address */
+  
+/*
+ * This ioctl is only used by the scsi-cd driver.  
+   It is for playing audio in logical block addressing mode.
+ */
+#define CDROMPLAYBLK		0x5317	/* (struct cdrom_blk) */
+
+/* 
+ * These ioctls are only used in optcd.c
+ */
+#define CDROMREADALL		0x5318	/* read all 2646 bytes */
+
+/* 
+ * These ioctls are (now) only in ide-cd.c for controlling 
+ * drive spindown time.  They should be implemented in the
+ * Uniform driver, via generic packet commands, GPCMD_MODE_SELECT_10,
+ * GPCMD_MODE_SENSE_10 and the GPMODE_POWER_PAGE...
+ *  -Erik
+ */
+#define CDROMGETSPINDOWN        0x531d
+#define CDROMSETSPINDOWN        0x531e
+
+/* 
+ * These ioctls are implemented through the uniform CD-ROM driver
+ * They _will_ be adopted by all CD-ROM drivers, when all the CD-ROM
+ * drivers are eventually ported to the uniform CD-ROM driver interface.
+ */
+#define CDROMCLOSETRAY		0x5319	/* pendant of CDROMEJECT */
+#define CDROM_SET_OPTIONS	0x5320  /* Set behavior options */
+#define CDROM_CLEAR_OPTIONS	0x5321  /* Clear behavior options */
+#define CDROM_SELECT_SPEED	0x5322  /* Set the CD-ROM speed */
+#define CDROM_SELECT_DISC	0x5323  /* Select disc (for juke-boxes) */
+#define CDROM_MEDIA_CHANGED	0x5325  /* Check is media changed  */
+#define CDROM_DRIVE_STATUS	0x5326  /* Get tray position, etc. */
+#define CDROM_DISC_STATUS	0x5327  /* Get disc type, etc. */
+#define CDROM_CHANGER_NSLOTS    0x5328  /* Get number of slots */
+#define CDROM_LOCKDOOR		0x5329  /* lock or unlock door */
+#define CDROM_DEBUG		0x5330	/* Turn debug messages on/off */
+#define CDROM_GET_CAPABILITY	0x5331	/* get capabilities */
+
+/* Note that scsi/scsi_ioctl.h also uses 0x5382 - 0x5386.
+ * Future CDROM ioctls should be kept below 0x537F
+ */
+
+/* This ioctl is only used by sbpcd at the moment */
+#define CDROMAUDIOBUFSIZ        0x5382	/* set the audio buffer size */
+					/* conflict with SCSI_IOCTL_GET_IDLUN */
+
+/* DVD-ROM Specific ioctls */
+#define DVD_READ_STRUCT		0x5390  /* Read structure */
+#define DVD_WRITE_STRUCT	0x5391  /* Write structure */
+#define DVD_AUTH		0x5392  /* Authentication */
+
+#define CDROM_SEND_PACKET	0x5393	/* send a packet to the drive */
+#define CDROM_NEXT_WRITABLE	0x5394	/* get next writable block */
+#define CDROM_LAST_WRITTEN	0x5395	/* get last block written on disc */
+
+/*******************************************************
+ * CDROM IOCTL structures
+ *******************************************************/
+
+/* Address in MSF format */
+struct cdrom_msf0		
+{
+	__u8	minute;
+	__u8	second;
+	__u8	frame;
+};
+
+/* Address in either MSF or logical format */
+union cdrom_addr		
+{
+	struct cdrom_msf0	msf;
+	int			lba;
+};
+
+/* This struct is used by the CDROMPLAYMSF ioctl */ 
+struct cdrom_msf 
+{
+	__u8	cdmsf_min0;	/* start minute */
+	__u8	cdmsf_sec0;	/* start second */
+	__u8	cdmsf_frame0;	/* start frame */
+	__u8	cdmsf_min1;	/* end minute */
+	__u8	cdmsf_sec1;	/* end second */
+	__u8	cdmsf_frame1;	/* end frame */
+};
+
+/* This struct is used by the CDROMPLAYTRKIND ioctl */
+struct cdrom_ti 
+{
+	__u8	cdti_trk0;	/* start track */
+	__u8	cdti_ind0;	/* start index */
+	__u8	cdti_trk1;	/* end track */
+	__u8	cdti_ind1;	/* end index */
+};
+
+/* This struct is used by the CDROMREADTOCHDR ioctl */
+struct cdrom_tochdr 	
+{
+	__u8	cdth_trk0;	/* start track */
+	__u8	cdth_trk1;	/* end track */
+};
+
+/* This struct is used by the CDROMVOLCTRL and CDROMVOLREAD ioctls */
+struct cdrom_volctrl
+{
+	__u8	channel0;
+	__u8	channel1;
+	__u8	channel2;
+	__u8	channel3;
+};
+
+/* This struct is used by the CDROMSUBCHNL ioctl */
+struct cdrom_subchnl 
+{
+	__u8	cdsc_format;
+	__u8	cdsc_audiostatus;
+	__u8	cdsc_adr:	4;
+	__u8	cdsc_ctrl:	4;
+	__u8	cdsc_trk;
+	__u8	cdsc_ind;
+	union cdrom_addr cdsc_absaddr;
+	union cdrom_addr cdsc_reladdr;
+};
+
+
+/* This struct is used by the CDROMREADTOCENTRY ioctl */
+struct cdrom_tocentry 
+{
+	__u8	cdte_track;
+	__u8	cdte_adr	:4;
+	__u8	cdte_ctrl	:4;
+	__u8	cdte_format;
+	union cdrom_addr cdte_addr;
+	__u8	cdte_datamode;
+};
+
+/* This struct is used by the CDROMREADMODE1, and CDROMREADMODE2 ioctls */
+struct cdrom_read      
+{
+	int	cdread_lba;
+	char 	*cdread_bufaddr;
+	int	cdread_buflen;
+};
+
+/* This struct is used by the CDROMREADAUDIO ioctl */
+struct cdrom_read_audio
+{
+	union cdrom_addr addr; /* frame address */
+	__u8 addr_format;    /* CDROM_LBA or CDROM_MSF */
+	int nframes;           /* number of 2352-byte-frames to read at once */
+	__u8 *buf;           /* frame buffer (size: nframes*2352 bytes) */
+};
+
+/* This struct is used with the CDROMMULTISESSION ioctl */
+struct cdrom_multisession
+{
+	union cdrom_addr addr; /* frame address: start-of-last-session 
+	                           (not the new "frame 16"!).  Only valid
+	                           if the "xa_flag" is true. */
+	__u8 xa_flag;        /* 1: "is XA disk" */
+	__u8 addr_format;    /* CDROM_LBA or CDROM_MSF */
+};
+
+/* This struct is used with the CDROM_GET_MCN ioctl.  
+ * Very few audio discs actually have Universal Product Code information, 
+ * which should just be the Medium Catalog Number on the box.  Also note 
+ * that the way the codeis written on CD is _not_ uniform across all discs!
+ */  
+struct cdrom_mcn 
+{
+  __u8 medium_catalog_number[14]; /* 13 ASCII digits, null-terminated */
+};
+
+/* This is used by the CDROMPLAYBLK ioctl */
+struct cdrom_blk 
+{
+	unsigned from;
+	unsigned short len;
+};
+
+#define CDROM_PACKET_SIZE	12
+
+#define CGC_DATA_UNKNOWN	0
+#define CGC_DATA_WRITE		1
+#define CGC_DATA_READ		2
+#define CGC_DATA_NONE		3
+
+/* for CDROM_PACKET_COMMAND ioctl */
+struct cdrom_generic_command
+{
+	unsigned char 		cmd[CDROM_PACKET_SIZE];
+	unsigned char 		*buffer;
+	unsigned int 		buflen;
+	int			stat;
+	struct request_sense	*sense;
+	unsigned char		data_direction;
+	int			quiet;
+	int			timeout;
+	void			*reserved[1];
+};
+
+
+/*
+ * A CD-ROM physical sector size is 2048, 2052, 2056, 2324, 2332, 2336, 
+ * 2340, or 2352 bytes long.  
+
+*         Sector types of the standard CD-ROM data formats:
+ *
+ * format   sector type               user data size (bytes)
+ * -----------------------------------------------------------------------------
+ *   1     (Red Book)    CD-DA          2352    (CD_FRAMESIZE_RAW)
+ *   2     (Yellow Book) Mode1 Form1    2048    (CD_FRAMESIZE)
+ *   3     (Yellow Book) Mode1 Form2    2336    (CD_FRAMESIZE_RAW0)
+ *   4     (Green Book)  Mode2 Form1    2048    (CD_FRAMESIZE)
+ *   5     (Green Book)  Mode2 Form2    2328    (2324+4 spare bytes)
+ *
+ *
+ *       The layout of the standard CD-ROM data formats:
+ * -----------------------------------------------------------------------------
+ * - audio (red):                  | audio_sample_bytes |
+ *                                 |        2352        |
+ *
+ * - data (yellow, mode1):         | sync - head - data - EDC - zero - ECC |
+ *                                 |  12  -   4  - 2048 -  4  -   8  - 276 |
+ *
+ * - data (yellow, mode2):         | sync - head - data |
+ *                                 |  12  -   4  - 2336 |
+ *
+ * - XA data (green, mode2 form1): | sync - head - sub - data - EDC - ECC |
+ *                                 |  12  -   4  -  8  - 2048 -  4  - 276 |
+ *
+ * - XA data (green, mode2 form2): | sync - head - sub - data - Spare |
+ *                                 |  12  -   4  -  8  - 2324 -  4    |
+ *
+ */
+
+/* Some generally useful CD-ROM information -- mostly based on the above */
+#define CD_MINS              74 /* max. minutes per CD, not really a limit */
+#define CD_SECS              60 /* seconds per minute */
+#define CD_FRAMES            75 /* frames per second */
+#define CD_SYNC_SIZE         12 /* 12 sync bytes per raw data frame */
+#define CD_MSF_OFFSET       150 /* MSF numbering offset of first frame */
+#define CD_CHUNK_SIZE        24 /* lowest-level "data bytes piece" */
+#define CD_NUM_OF_CHUNKS     98 /* chunks per frame */
+#define CD_FRAMESIZE_SUB     96 /* subchannel data "frame" size */
+#define CD_HEAD_SIZE          4 /* header (address) bytes per raw data frame */
+#define CD_SUBHEAD_SIZE       8 /* subheader bytes per raw XA data frame */
+#define CD_EDC_SIZE           4 /* bytes EDC per most raw data frame types */
+#define CD_ZERO_SIZE          8 /* bytes zero per yellow book mode 1 frame */
+#define CD_ECC_SIZE         276 /* bytes ECC per most raw data frame types */
+#define CD_FRAMESIZE       2048 /* bytes per frame, "cooked" mode */
+#define CD_FRAMESIZE_RAW   2352 /* bytes per frame, "raw" mode */
+#define CD_FRAMESIZE_RAWER 2646 /* The maximum possible returned bytes */ 
+/* most drives don't deliver everything: */
+#define CD_FRAMESIZE_RAW1 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE) /*2340*/
+#define CD_FRAMESIZE_RAW0 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE-CD_HEAD_SIZE) /*2336*/
+
+#define CD_XA_HEAD        (CD_HEAD_SIZE+CD_SUBHEAD_SIZE) /* "before data" part of raw XA frame */
+#define CD_XA_TAIL        (CD_EDC_SIZE+CD_ECC_SIZE) /* "after data" part of raw XA frame */
+#define CD_XA_SYNC_HEAD   (CD_SYNC_SIZE+CD_XA_HEAD) /* sync bytes + header of XA frame */
+
+/* CD-ROM address types (cdrom_tocentry.cdte_format) */
+#define	CDROM_LBA 0x01 /* "logical block": first frame is #0 */
+#define	CDROM_MSF 0x02 /* "minute-second-frame": binary, not bcd here! */
+
+/* bit to tell whether track is data or audio (cdrom_tocentry.cdte_ctrl) */
+#define	CDROM_DATA_TRACK	0x04
+
+/* The leadout track is always 0xAA, regardless of # of tracks on disc */
+#define	CDROM_LEADOUT		0xAA
+
+/* audio states (from SCSI-2, but seen with other drives, too) */
+#define	CDROM_AUDIO_INVALID	0x00	/* audio status not supported */
+#define	CDROM_AUDIO_PLAY	0x11	/* audio play operation in progress */
+#define	CDROM_AUDIO_PAUSED	0x12	/* audio play operation paused */
+#define	CDROM_AUDIO_COMPLETED	0x13	/* audio play successfully completed */
+#define	CDROM_AUDIO_ERROR	0x14	/* audio play stopped due to error */
+#define	CDROM_AUDIO_NO_STATUS	0x15	/* no current audio status to return */
+
+/* capability flags used with the uniform CD-ROM driver */ 
+#define CDC_CLOSE_TRAY		0x1     /* caddy systems _can't_ close */
+#define CDC_OPEN_TRAY		0x2     /* but _can_ eject.  */
+#define CDC_LOCK		0x4     /* disable manual eject */
+#define CDC_SELECT_SPEED 	0x8     /* programmable speed */
+#define CDC_SELECT_DISC		0x10    /* select disc from juke-box */
+#define CDC_MULTI_SESSION 	0x20    /* read sessions>1 */
+#define CDC_MCN			0x40    /* Medium Catalog Number */
+#define CDC_MEDIA_CHANGED 	0x80    /* media changed */
+#define CDC_PLAY_AUDIO		0x100   /* audio functions */
+#define CDC_RESET               0x200   /* hard reset device */
+#define CDC_IOCTLS              0x400   /* driver has non-standard ioctls */
+#define CDC_DRIVE_STATUS        0x800   /* driver implements drive status */
+#define CDC_GENERIC_PACKET	0x1000	/* driver implements generic packets */
+#define CDC_CD_R		0x2000	/* drive is a CD-R */
+#define CDC_CD_RW		0x4000	/* drive is a CD-RW */
+#define CDC_DVD			0x8000	/* drive is a DVD */
+#define CDC_DVD_R		0x10000	/* drive can write DVD-R */
+#define CDC_DVD_RAM		0x20000	/* drive can write DVD-RAM */
+#define CDC_MO_DRIVE		0x40000 /* drive is an MO device */
+#define CDC_MRW			0x80000 /* drive can read MRW */
+#define CDC_MRW_W		0x100000 /* drive can write MRW */
+#define CDC_RAM			0x200000 /* ok to open for WRITE */
+
+/* drive status possibilities returned by CDROM_DRIVE_STATUS ioctl */
+#define CDS_NO_INFO		0	/* if not implemented */
+#define CDS_NO_DISC		1
+#define CDS_TRAY_OPEN		2
+#define CDS_DRIVE_NOT_READY	3
+#define CDS_DISC_OK		4
+
+/* return values for the CDROM_DISC_STATUS ioctl */
+/* can also return CDS_NO_[INFO|DISC], from above */
+#define CDS_AUDIO		100
+#define CDS_DATA_1		101
+#define CDS_DATA_2		102
+#define CDS_XA_2_1		103
+#define CDS_XA_2_2		104
+#define CDS_MIXED		105
+
+/* User-configurable behavior options for the uniform CD-ROM driver */
+#define CDO_AUTO_CLOSE		0x1     /* close tray on first open() */
+#define CDO_AUTO_EJECT		0x2     /* open tray on last release() */
+#define CDO_USE_FFLAGS		0x4     /* use O_NONBLOCK information on open */
+#define CDO_LOCK		0x8     /* lock tray on open files */
+#define CDO_CHECK_TYPE		0x10    /* check type on open for data */
+
+/* Special codes used when specifying changer slots. */
+#define CDSL_NONE       	((int) (~0U>>1)-1)
+#define CDSL_CURRENT    	((int) (~0U>>1))
+
+/* For partition based multisession access. IDE can handle 64 partitions
+ * per drive - SCSI CD-ROM's use minors to differentiate between the
+ * various drives, so we can't do multisessions the same way there.
+ * Use the -o session=x option to mount on them.
+ */
+#define CD_PART_MAX		64
+#define CD_PART_MASK		(CD_PART_MAX - 1)
+
+/*********************************************************************
+ * Generic Packet commands, MMC commands, and such
+ *********************************************************************/
+
+ /* The generic packet command opcodes for CD/DVD Logical Units,
+ * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
+#define GPCMD_BLANK			    0xa1
+#define GPCMD_CLOSE_TRACK		    0x5b
+#define GPCMD_FLUSH_CACHE		    0x35
+#define GPCMD_FORMAT_UNIT		    0x04
+#define GPCMD_GET_CONFIGURATION		    0x46
+#define GPCMD_GET_EVENT_STATUS_NOTIFICATION 0x4a
+#define GPCMD_GET_PERFORMANCE		    0xac
+#define GPCMD_INQUIRY			    0x12
+#define GPCMD_LOAD_UNLOAD		    0xa6
+#define GPCMD_MECHANISM_STATUS		    0xbd
+#define GPCMD_MODE_SELECT_10		    0x55
+#define GPCMD_MODE_SENSE_10		    0x5a
+#define GPCMD_PAUSE_RESUME		    0x4b
+#define GPCMD_PLAY_AUDIO_10		    0x45
+#define GPCMD_PLAY_AUDIO_MSF		    0x47
+#define GPCMD_PLAY_AUDIO_TI		    0x48
+#define GPCMD_PLAY_CD			    0xbc
+#define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL  0x1e
+#define GPCMD_READ_10			    0x28
+#define GPCMD_READ_12			    0xa8
+#define GPCMD_READ_CDVD_CAPACITY	    0x25
+#define GPCMD_READ_CD			    0xbe
+#define GPCMD_READ_CD_MSF		    0xb9
+#define GPCMD_READ_DISC_INFO		    0x51
+#define GPCMD_READ_DVD_STRUCTURE	    0xad
+#define GPCMD_READ_FORMAT_CAPACITIES	    0x23
+#define GPCMD_READ_HEADER		    0x44
+#define GPCMD_READ_TRACK_RZONE_INFO	    0x52
+#define GPCMD_READ_SUBCHANNEL		    0x42
+#define GPCMD_READ_TOC_PMA_ATIP		    0x43
+#define GPCMD_REPAIR_RZONE_TRACK	    0x58
+#define GPCMD_REPORT_KEY		    0xa4
+#define GPCMD_REQUEST_SENSE		    0x03
+#define GPCMD_RESERVE_RZONE_TRACK	    0x53
+#define GPCMD_SCAN			    0xba
+#define GPCMD_SEEK			    0x2b
+#define GPCMD_SEND_DVD_STRUCTURE	    0xad
+#define GPCMD_SEND_EVENT		    0xa2
+#define GPCMD_SEND_KEY			    0xa3
+#define GPCMD_SEND_OPC			    0x54
+#define GPCMD_SET_READ_AHEAD		    0xa7
+#define GPCMD_SET_STREAMING		    0xb6
+#define GPCMD_START_STOP_UNIT		    0x1b
+#define GPCMD_STOP_PLAY_SCAN		    0x4e
+#define GPCMD_TEST_UNIT_READY		    0x00
+#define GPCMD_VERIFY_10			    0x2f
+#define GPCMD_WRITE_10			    0x2a
+#define GPCMD_WRITE_AND_VERIFY_10	    0x2e
+/* This is listed as optional in ATAPI 2.6, but is (curiously) 
+ * missing from Mt. Fuji, Table 57.  It _is_ mentioned in Mt. Fuji
+ * Table 377 as an MMC command for SCSi devices though...  Most ATAPI
+ * drives support it. */
+#define GPCMD_SET_SPEED			    0xbb
+/* This seems to be a SCSI specific CD-ROM opcode 
+ * to play data at track/index */
+#define GPCMD_PLAYAUDIO_TI		    0x48
+/*
+ * From MS Media Status Notification Support Specification. For
+ * older drives only.
+ */
+#define GPCMD_GET_MEDIA_STATUS		    0xda
+
+/* Mode page codes for mode sense/set */
+#define GPMODE_VENDOR_PAGE		0x00
+#define GPMODE_R_W_ERROR_PAGE		0x01
+#define GPMODE_WRITE_PARMS_PAGE		0x05
+#define GPMODE_WCACHING_PAGE		0x08
+#define GPMODE_AUDIO_CTL_PAGE		0x0e
+#define GPMODE_POWER_PAGE		0x1a
+#define GPMODE_FAULT_FAIL_PAGE		0x1c
+#define GPMODE_TO_PROTECT_PAGE		0x1d
+#define GPMODE_CAPABILITIES_PAGE	0x2a
+#define GPMODE_ALL_PAGES		0x3f
+/* Not in Mt. Fuji, but in ATAPI 2.6 -- depricated now in favor
+ * of MODE_SENSE_POWER_PAGE */
+#define GPMODE_CDROM_PAGE		0x0d
+
+
+
+/* DVD struct types */
+#define DVD_STRUCT_PHYSICAL	0x00
+#define DVD_STRUCT_COPYRIGHT	0x01
+#define DVD_STRUCT_DISCKEY	0x02
+#define DVD_STRUCT_BCA		0x03
+#define DVD_STRUCT_MANUFACT	0x04
+
+struct dvd_layer {
+	__u8 book_version	: 4;
+	__u8 book_type		: 4;
+	__u8 min_rate		: 4;
+	__u8 disc_size		: 4;
+	__u8 layer_type		: 4;
+	__u8 track_path		: 1;
+	__u8 nlayers		: 2;
+	__u8 track_density	: 4;
+	__u8 linear_density	: 4;
+	__u8 bca		: 1;
+	__u32 start_sector;
+	__u32 end_sector;
+	__u32 end_sector_l0;
+};
+
+#define DVD_LAYERS	4
+
+struct dvd_physical {
+	__u8 type;
+	__u8 layer_num;
+	struct dvd_layer layer[DVD_LAYERS];
+};
+
+struct dvd_copyright {
+	__u8 type;
+
+	__u8 layer_num;
+	__u8 cpst;
+	__u8 rmi;
+};
+
+struct dvd_disckey {
+	__u8 type;
+
+	unsigned agid		: 2;
+	__u8 value[2048];
+};
+
+struct dvd_bca {
+	__u8 type;
+
+	int len;
+	__u8 value[188];
+};
+
+struct dvd_manufact {
+	__u8 type;
+
+	__u8 layer_num;
+	int len;
+	__u8 value[2048];
+};
+
+typedef union {
+	__u8 type;
+
+	struct dvd_physical	physical;
+	struct dvd_copyright	copyright;
+	struct dvd_disckey	disckey;
+	struct dvd_bca		bca;
+	struct dvd_manufact	manufact;
+} dvd_struct;
+
+/*
+ * DVD authentication ioctl
+ */
+
+/* Authentication states */
+#define DVD_LU_SEND_AGID	0
+#define DVD_HOST_SEND_CHALLENGE	1
+#define DVD_LU_SEND_KEY1	2
+#define DVD_LU_SEND_CHALLENGE	3
+#define DVD_HOST_SEND_KEY2	4
+
+/* Termination states */
+#define DVD_AUTH_ESTABLISHED	5
+#define DVD_AUTH_FAILURE	6
+
+/* Other functions */
+#define DVD_LU_SEND_TITLE_KEY	7
+#define DVD_LU_SEND_ASF		8
+#define DVD_INVALIDATE_AGID	9
+#define DVD_LU_SEND_RPC_STATE	10
+#define DVD_HOST_SEND_RPC_STATE	11
+
+/* State data */
+typedef __u8 dvd_key[5];		/* 40-bit value, MSB is first elem. */
+typedef __u8 dvd_challenge[10];	/* 80-bit value, MSB is first elem. */
+
+struct dvd_lu_send_agid {
+	__u8 type;
+	unsigned agid		: 2;
+};
+
+struct dvd_host_send_challenge {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_challenge chal;
+};
+
+struct dvd_send_key {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_key key;
+};
+
+struct dvd_lu_send_challenge {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_challenge chal;
+};
+
+#define DVD_CPM_NO_COPYRIGHT	0
+#define DVD_CPM_COPYRIGHTED	1
+
+#define DVD_CP_SEC_NONE		0
+#define DVD_CP_SEC_EXIST	1
+
+#define DVD_CGMS_UNRESTRICTED	0
+#define DVD_CGMS_SINGLE		2
+#define DVD_CGMS_RESTRICTED	3
+
+struct dvd_lu_send_title_key {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_key title_key;
+	int lba;
+	unsigned cpm		: 1;
+	unsigned cp_sec		: 1;
+	unsigned cgms		: 2;
+};
+
+struct dvd_lu_send_asf {
+	__u8 type;
+	unsigned agid		: 2;
+
+	unsigned asf		: 1;
+};
+
+struct dvd_host_send_rpcstate {
+	__u8 type;
+	__u8 pdrc;
+};
+
+struct dvd_lu_send_rpcstate {
+	__u8 type		: 2;
+	__u8 vra		: 3;
+	__u8 ucca		: 3;
+	__u8 region_mask;
+	__u8 rpc_scheme;
+};
+
+typedef union {
+	__u8 type;
+
+	struct dvd_lu_send_agid		lsa;
+	struct dvd_host_send_challenge	hsc;
+	struct dvd_send_key		lsk;
+	struct dvd_lu_send_challenge	lsc;
+	struct dvd_send_key		hsk;
+	struct dvd_lu_send_title_key	lstk;
+	struct dvd_lu_send_asf		lsasf;
+	struct dvd_host_send_rpcstate	hrpcs;
+	struct dvd_lu_send_rpcstate	lrpcs;
+} dvd_authinfo;
+
+struct request_sense {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 valid		: 1;
+	__u8 error_code		: 7;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 error_code		: 7;
+	__u8 valid		: 1;
+#endif
+	__u8 segment_number;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 2;
+	__u8 ili		: 1;
+	__u8 reserved2		: 1;
+	__u8 sense_key		: 4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 sense_key		: 4;
+	__u8 reserved2		: 1;
+	__u8 ili		: 1;
+	__u8 reserved1		: 2;
+#endif
+	__u8 information[4];
+	__u8 add_sense_len;
+	__u8 command_info[4];
+	__u8 asc;
+	__u8 ascq;
+	__u8 fruc;
+	__u8 sks[3];
+	__u8 asb[46];
+};
+
+/*
+ * feature profile
+ */
+#define CDF_RWRT	0x0020	/* "Random Writable" */
+#define CDF_HWDM	0x0024	/* "Hardware Defect Management" */
+#define CDF_MRW 	0x0028
+
+/*
+ * media status bits
+ */
+#define CDM_MRW_NOTMRW			0
+#define CDM_MRW_BGFORMAT_INACTIVE	1
+#define CDM_MRW_BGFORMAT_ACTIVE		2
+#define CDM_MRW_BGFORMAT_COMPLETE	3
+
+/*
+ * mrw address spaces
+ */
+#define MRW_LBA_DMA			0
+#define MRW_LBA_GAA			1
+
+/*
+ * mrw mode pages (first is deprecated) -- probed at init time and
+ * cdi->mrw_mode_page is set
+ */
+#define MRW_MODE_PC_PRE1		0x2c
+#define MRW_MODE_PC			0x03
+
+struct mrw_feature_desc {
+	__u16 feature_code;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 2;
+	__u8 feature_version	: 4;
+	__u8 persistent		: 1;
+	__u8 curr		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 curr		: 1;
+	__u8 persistent		: 1;
+	__u8 feature_version	: 4;
+	__u8 reserved1		: 2;
+#endif
+	__u8 add_len;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved2		: 7;
+	__u8 write		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 write		: 1;
+	__u8 reserved2		: 7;
+#endif
+	__u8 reserved3;
+	__u8 reserved4;
+	__u8 reserved5;
+};
+
+/* cf. mmc4r02g.pdf 5.3.10 Random Writable Feature (0020h) pg 197 of 635 */
+struct rwrt_feature_desc {
+	__u16 feature_code;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 2;
+	__u8 feature_version	: 4;
+	__u8 persistent		: 1;
+	__u8 curr		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 curr		: 1;
+	__u8 persistent		: 1;
+	__u8 feature_version	: 4;
+	__u8 reserved1		: 2;
+#endif
+	__u8 add_len;
+	__u32 last_lba;
+	__u32 block_size;
+	__u16 blocking;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved2		: 7;
+	__u8 page_present	: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 page_present	: 1;
+	__u8 reserved2		: 7;
+#endif
+	__u8 reserved3;
+};
+
+typedef struct {
+	__u16 disc_information_length;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1			: 3;
+        __u8 erasable			: 1;
+        __u8 border_status		: 2;
+        __u8 disc_status		: 2;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+        __u8 disc_status		: 2;
+        __u8 border_status		: 2;
+        __u8 erasable			: 1;
+	__u8 reserved1			: 3;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	__u8 n_first_track;
+	__u8 n_sessions_lsb;
+	__u8 first_track_lsb;
+	__u8 last_track_lsb;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 did_v			: 1;
+        __u8 dbc_v			: 1;
+        __u8 uru			: 1;
+        __u8 reserved2			: 2;
+	__u8 dbit			: 1;
+	__u8 mrw_status			: 2;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 mrw_status			: 2;
+	__u8 dbit			: 1;
+        __u8 reserved2			: 2;
+        __u8 uru			: 1;
+        __u8 dbc_v			: 1;
+	__u8 did_v			: 1;
+#endif
+	__u8 disc_type;
+	__u8 n_sessions_msb;
+	__u8 first_track_msb;
+	__u8 last_track_msb;
+	__u32 disc_id;
+	__u32 lead_in;
+	__u32 lead_out;
+	__u8 disc_bar_code[8];
+	__u8 reserved3;
+	__u8 n_opc;
+} disc_information;
+
+typedef struct {
+	__u16 track_information_length;
+	__u8 track_lsb;
+	__u8 session_lsb;
+	__u8 reserved1;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved2			: 2;
+        __u8 damage			: 1;
+        __u8 copy			: 1;
+        __u8 track_mode			: 4;
+	__u8 rt				: 1;
+	__u8 blank			: 1;
+	__u8 packet			: 1;
+	__u8 fp				: 1;
+	__u8 data_mode			: 4;
+	__u8 reserved3			: 6;
+	__u8 lra_v			: 1;
+	__u8 nwa_v			: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+        __u8 track_mode			: 4;
+        __u8 copy			: 1;
+        __u8 damage			: 1;
+	__u8 reserved2			: 2;
+	__u8 data_mode			: 4;
+	__u8 fp				: 1;
+	__u8 packet			: 1;
+	__u8 blank			: 1;
+	__u8 rt				: 1;
+	__u8 nwa_v			: 1;
+	__u8 lra_v			: 1;
+	__u8 reserved3			: 6;
+#endif
+	__u32 track_start;
+	__u32 next_writable;
+	__u32 free_blocks;
+	__u32 fixed_packet_size;
+	__u32 track_size;
+	__u32 last_rec_address;
+} track_information;
+
+struct feature_header {
+	__u32 data_len;
+	__u8 reserved1;
+	__u8 reserved2;
+	__u16 curr_profile;
+};
+
+struct mode_page_header {
+	__u16 mode_data_length;
+	__u8 medium_type;
+	__u8 reserved1;
+	__u8 reserved2;
+	__u8 reserved3;
+	__u16 desc_length;
+};
+
+#ifdef __KERNEL__
+#include <linux/fs.h>		/* not really needed, later.. */
+#include <linux/device.h>
+
+/*
+ * _OLD will use PIO transfer on atapi devices, _BPC_* will use DMA
+ */
+#define CDDA_OLD		0	/* old style */
+#define CDDA_BPC_SINGLE		1	/* single frame block pc */
+#define CDDA_BPC_FULL		2	/* multi frame block pc */
+
+/* Uniform cdrom data structures for cdrom.c */
+struct cdrom_device_info {
+	struct cdrom_device_ops  *ops;  /* link to device_ops */
+	struct cdrom_device_info *next; /* next device_info for this major */
+	struct gendisk *disk;		/* matching block layer disk */
+	void *handle;		        /* driver-dependent data */
+/* specifications */
+	int mask;                       /* mask of capability: disables them */
+	int speed;			/* maximum speed for reading data */
+	int capacity;			/* number of discs in jukebox */
+/* device-related storage */
+	int options		: 30;	/* options flags */
+	unsigned mc_flags	: 2;	/* media change buffer flags */
+    	int use_count;                  /* number of times device opened */
+    	char name[20];                  /* name of the device type */
+/* per-device flags */
+        __u8 sanyo_slot		: 2;	/* Sanyo 3 CD changer support */
+        __u8 reserved		: 6;	/* not used yet */
+	int cdda_method;		/* see flags */
+	__u8 last_sense;
+	int for_data;
+	int (*exit)(struct cdrom_device_info *);
+	int mrw_mode_page;
+};
+
+struct cdrom_device_ops {
+/* routines */
+	int (*open) (struct cdrom_device_info *, int);
+	void (*release) (struct cdrom_device_info *);
+	int (*drive_status) (struct cdrom_device_info *, int);
+	int (*media_changed) (struct cdrom_device_info *, int);
+	int (*tray_move) (struct cdrom_device_info *, int);
+	int (*lock_door) (struct cdrom_device_info *, int);
+	int (*select_speed) (struct cdrom_device_info *, int);
+	int (*select_disc) (struct cdrom_device_info *, int);
+	int (*get_last_session) (struct cdrom_device_info *,
+				 struct cdrom_multisession *);
+	int (*get_mcn) (struct cdrom_device_info *,
+			struct cdrom_mcn *);
+	/* hard reset device */
+	int (*reset) (struct cdrom_device_info *);
+	/* play stuff */
+	int (*audio_ioctl) (struct cdrom_device_info *,unsigned int, void *);
+	/* dev-specific */
+ 	int (*dev_ioctl) (struct cdrom_device_info *,
+			  unsigned int, unsigned long);
+/* driver specifications */
+	const int capability;   /* capability flags */
+	int n_minors;           /* number of active minor devices */
+	/* handle uniform packets for scsi type devices (scsi,atapi) */
+	int (*generic_packet) (struct cdrom_device_info *,
+			       struct cdrom_generic_command *);
+};
+
+/* the general block_device operations structure: */
+extern int cdrom_open(struct cdrom_device_info *cdi, struct inode *ip,
+			struct file *fp);
+extern int cdrom_release(struct cdrom_device_info *cdi, struct file *fp);
+extern int cdrom_ioctl(struct cdrom_device_info *cdi, struct inode *ip,
+		unsigned int cmd, unsigned long arg);
+extern int cdrom_media_changed(struct cdrom_device_info *);
+#if defined(CONFIG_SUPERMOUNT) || defined(CONFIG_SUPERMOUNT_MODULE)
+extern int cdrom_mediactl(struct cdrom_device_info *, struct block_device *, int, int);
+#endif
+
+extern int register_cdrom(struct cdrom_device_info *cdi);
+extern int unregister_cdrom(struct cdrom_device_info *cdi);
+
+typedef struct {
+    int data;
+    int audio;
+    int cdi;
+    int xa;
+    long error;
+} tracktype;
+
+extern int cdrom_get_last_written(struct cdrom_device_info *cdi, long *last_written);
+extern int cdrom_number_of_slots(struct cdrom_device_info *cdi);
+extern int cdrom_mode_select(struct cdrom_device_info *cdi,
+			     struct cdrom_generic_command *cgc);
+extern int cdrom_mode_sense(struct cdrom_device_info *cdi,
+			    struct cdrom_generic_command *cgc,
+			    int page_code, int page_control);
+extern void init_cdrom_command(struct cdrom_generic_command *cgc,
+			       void *buffer, int len, int type);
+
+/* The SCSI spec says there could be 256 slots. */
+#define CDROM_MAX_SLOTS	256
+
+struct cdrom_mechstat_header {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 fault         : 1;
+	__u8 changer_state : 2;
+	__u8 curslot       : 5;
+	__u8 mech_state    : 3;
+	__u8 door_open     : 1;
+	__u8 reserved1     : 4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 curslot       : 5;
+	__u8 changer_state : 2;
+	__u8 fault         : 1;
+	__u8 reserved1     : 4;
+	__u8 door_open     : 1;
+	__u8 mech_state    : 3;
+#endif
+	__u8     curlba[3];
+	__u8     nslots;
+	__u16 slot_tablelen;
+};
+
+struct cdrom_slot {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 disc_present : 1;
+	__u8 reserved1    : 6;
+	__u8 change       : 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 change       : 1;
+	__u8 reserved1    : 6;
+	__u8 disc_present : 1;
+#endif
+	__u8 reserved2[3];
+};
+
+struct cdrom_changer_info {
+	struct cdrom_mechstat_header hdr;
+	struct cdrom_slot slots[CDROM_MAX_SLOTS];
+};
+
+typedef enum {
+	mechtype_caddy = 0,
+	mechtype_tray  = 1,
+	mechtype_popup = 2,
+	mechtype_individual_changer = 4,
+	mechtype_cartridge_changer  = 5
+} mechtype_t;
+
+typedef struct {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 ps			: 1;
+	__u8 reserved1		: 1;
+	__u8 page_code		: 6;
+        __u8 page_length;
+	__u8 reserved2		: 1;
+	__u8 bufe		: 1;
+	__u8 ls_v		: 1;
+	__u8 test_write		: 1;
+        __u8 write_type		: 4;
+	__u8 multi_session	: 2; /* or border, DVD */
+	__u8 fp			: 1;
+	__u8 copy		: 1;
+	__u8 track_mode		: 4;
+	__u8 reserved3		: 4;
+	__u8 data_block_type	: 4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 page_code		: 6;
+	__u8 reserved1		: 1;
+	__u8 ps			: 1;
+        __u8 page_length;
+        __u8 write_type		: 4;
+	__u8 test_write		: 1;
+	__u8 ls_v		: 1;
+	__u8 bufe		: 1;
+	__u8 reserved2		: 1;
+	__u8 track_mode		: 4;
+	__u8 copy		: 1;
+	__u8 fp			: 1;
+	__u8 multi_session	: 2; /* or border, DVD */
+	__u8 data_block_type	: 4;
+	__u8 reserved3		: 4;
+#endif
+	__u8 link_size;
+	__u8 reserved4;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved5		: 2;
+	__u8 app_code		: 6;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 app_code		: 6;
+	__u8 reserved5		: 2;
+#endif
+	__u8 session_format;
+	__u8 reserved6;
+	__u32 packet_size;
+	__u16 audio_pause;
+	__u8 mcn[16];
+	__u8 isrc[16];
+	__u8 subhdr0;
+	__u8 subhdr1;
+	__u8 subhdr2;
+	__u8 subhdr3;
+} __attribute__((packed)) write_param_page;
+
+struct modesel_head
+{
+	__u8	reserved1;
+	__u8	medium;
+	__u8	reserved2;
+	__u8	block_desc_length;
+	__u8	density;
+	__u8	number_of_blocks_hi;
+	__u8	number_of_blocks_med;
+	__u8	number_of_blocks_lo;
+	__u8	reserved3;
+	__u8	block_length_hi;
+	__u8	block_length_med;
+	__u8	block_length_lo;
+};
+
+typedef struct {
+	__u16 report_key_length;
+	__u8 reserved1;
+	__u8 reserved2;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 type_code			: 2;
+	__u8 vra			: 3;
+	__u8 ucca			: 3;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 ucca			: 3;
+	__u8 vra			: 3;
+	__u8 type_code			: 2;
+#endif
+	__u8 region_mask;
+	__u8 rpc_scheme;
+	__u8 reserved3;
+} rpc_state_t;
+
+struct event_header {
+	__u16 data_len;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 nea		: 1;
+	__u8 reserved1		: 4;
+	__u8 notification_class	: 3;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 notification_class	: 3;
+	__u8 reserved1		: 4;
+	__u8 nea		: 1;
+#endif
+	__u8 supp_event_class;
+};
+
+struct media_event_desc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 4;
+	__u8 media_event_code	: 4;
+	__u8 reserved2		: 6;
+	__u8 media_present	: 1;
+	__u8 door_open		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 media_event_code	: 4;
+	__u8 reserved1		: 4;
+	__u8 door_open		: 1;
+	__u8 media_present	: 1;
+	__u8 reserved2		: 6;
+#endif
+	__u8 start_slot;
+	__u8 end_slot;
+};
+
+extern int cdrom_get_media_event(struct cdrom_device_info *cdi, struct media_event_desc *med);
+extern int cdrom_is_mrw(struct cdrom_device_info *cdi, int *write);
+extern int cdrom_is_random_writable(struct cdrom_device_info *cdi, int *write);
+
+#endif  /* End of kernel only stuff */ 
+
+#endif  /* _LINUX_CDROM_H */
diff -Naurb udftools-1.0.0b3/cdmrw/Makefile.am udftools-1.0.0b3+cdmrw/cdmrw/Makefile.am
--- udftools-1.0.0b3/cdmrw/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ udftools-1.0.0b3+cdmrw/cdmrw/Makefile.am	2004-03-25 13:23:58.670145470 +0100
@@ -0,0 +1,4 @@
+bin_PROGRAMS = cdmrw
+cdmrw_SOURCES = cdmrw.c
+
+AM_CPPFLAGS = -D_LARGEFILE64_SOURCE
diff -Naurb udftools-1.0.0b3/cdmrw/Makefile.in udftools-1.0.0b3+cdmrw/cdmrw/Makefile.in
--- udftools-1.0.0b3/cdmrw/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ udftools-1.0.0b3+cdmrw/cdmrw/Makefile.in	2004-03-25 13:37:52.785629477 +0100
@@ -0,0 +1,418 @@
+# Makefile.in generated by automake 1.7.9 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+bin_PROGRAMS = cdmrw
+cdmrw_SOURCES = cdmrw.c cdrom.h
+
+AM_CPPFLAGS = -D_LARGEFILE64_SOURCE
+subdir = cdmrw
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/include/config.h
+CONFIG_CLEAN_FILES =
+bin_PROGRAMS = cdmrw$(EXEEXT)
+PROGRAMS = $(bin_PROGRAMS)
+
+am_cdmrw_OBJECTS =cdmrw.$(OBJEXT) 
+cdmrw_OBJECTS = $(am_cdmrw_OBJECTS)
+cdmrw_LDFLAGS =
+
+DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)/include
+depcomp = $(SHELL) $(top_srcdir)/config/depcomp
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) \
+	$(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+DIST_SOURCES = $(cdmrw_SOURCES)
+DIST_COMMON = $(srcdir)/Makefile.in ChangeLog Makefile.am
+SOURCES = $(cdmrw_SOURCES)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  cdmrw/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(bindir)
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	     || test -f $$p1 \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) $$p $(DESTDIR)$(bindir)/$$f"; \
+	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) $$p $(DESTDIR)$(bindir)/$$f || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f $(DESTDIR)$(bindir)/$$f"; \
+	  rm -f $(DESTDIR)$(bindir)/$$f; \
+	done
+
+clean-binPROGRAMS:
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  echo " rm -f $$p $$f"; \
+	  rm -f $$p $$f ; \
+	done
+cdmrw$(EXEEXT): $(cdmrw_OBJECTS) $(cdmrw_DEPENDENCIES) 
+	@rm -f cdmrw$(EXEEXT)
+	$(LINK) $(cdmrw_LDFLAGS) $(cdmrw_OBJECTS) $(cdmrw_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT) core *.core
+
+distclean-compile:
+	-rm -f *.tab.c
+
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+@am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+@am__fastdepCC_TRUE@	fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+@am__fastdepCC_TRUE@	  -c -o $@ `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+@am__fastdepCC_TRUE@	fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`
+
+.c.lo:
+@am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+@am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; \
+@am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+@am__fastdepCC_TRUE@	fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Plo' tmpdepfile='$(DEPDIR)/$*.TPlo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(bindir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-binPROGRAMS clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-binPROGRAMS
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-binPROGRAMS uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
+	clean-generic clean-libtool ctags distclean distclean-compile \
+	distclean-generic distclean-libtool distclean-tags distdir dvi \
+	dvi-am info info-am install install-am install-binPROGRAMS \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-binPROGRAMS \
+	uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

